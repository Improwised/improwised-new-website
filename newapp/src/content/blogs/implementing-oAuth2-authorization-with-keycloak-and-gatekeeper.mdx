---

title: "Implementing OAuth2 Authorization with Keycloak and Gatekeeper"
slug: 'implementing-oauth2-authorization-with-keycloak-gatekeeper'
description: 'This blog will delve into the technical details of implementing OAuth2 authorization using Keycloak as the identity and access management (IAM) solution, and Keycloak Gatekeeper as the authentication proxy. This setup is particularly useful for securing web applications deployed in a Kubernetes environment.'
seoTitle: 'Implementing OAuth2 Authorization with Keycloak and Gatekeeper'
seoDescription: 'This blog will delve into the technical details of implementing OAuth2 authorization using Keycloak as the identity and access management (IAM) solution, and Keycloak Gatekeeper as the authentication proxy.'
tags: [Gatekeeper,Authorization,Keycloak]
publishDate: 2025-02-18
author: 'Improwised'
image: '$lib/images/blogs/Implementing-OAuth2-head.webp'
---

import { Image } from 'astro:assets';
import blogImageInner from '$lib/images/blogs/Implementing-OAuth2-body.webp';


<div class="blog-details">

<h3>Keycloak Overview</h3>
<p>Keycloak is an open-source IAM platform provided by Red Hat&rsquo;s JBoss. It supports various authentication and authorization protocols, including OpenID Connect (OIDC) and SAML 2.0. For most use cases, OIDC is recommended due to its modern and efficient implementation compared to SAML.</p>
<h3>Setting Up Keycloak</h3>
<Image
    src={blogImageInner}
    alt="Blog Image"
    class="h-full w-full py-20 rounded-medium"
    />
<p>Before integrating Keycloak with Gatekeeper, you need to have a working Keycloak installation. Here are the key steps:</p>
<ol>
<li>
<p>Install Keycloak:Download and install Keycloak from the official Red Hat website or use a Docker image.Start the Keycloak server and access the administration console.</p>
</li>
</ol>
<ol start="2">
<li>
<p>Create a Realm:In the Keycloak administration console, create a new realm or use an existing one.Configure the realm settings as necessary.</p>
</li>
</ol>
<ol start="3">
<li>
<p>Create a Client:Within the realm, create a new client application.Set the Client ID and Access Type to confidential.Configure the Valid Redirect URLs to match your application's URL.Note the Client Secret from the "Credentials" tab.</p>
</li>
</ol>
<h3>Configuring Keycloak Gatekeeper</h3>
<p>Keycloak Gatekeeper is a transparent authentication proxy that integrates with the Keycloak authentication service. Here&rsquo;s how to set it up:</p>
<p><strong>Authentication Modes</strong></p>
<p>Gatekeeper supports both access tokens in browser cookies and bearer tokens in the Authorization header. This flexibility allows it to handle traditional clients and modern browser-based clients.</p>
<h4 >Configuration Steps</h4>
<ol>
<li>
<p>Deploy Gatekeeper:</p>
</li>
</ol>
<p>Gatekeeper can be deployed as a sidecar container within the same Kubernetes pod as your application or as a standalone service.Ensure the Kubernetes service points to the Gatekeeper rather than the application directly.</p>
<ol start="2">
<li>
<p>Configure Gatekeeper Client in Keycloak:</p>
</li>
</ol>
<p>In the Keycloak administration console, create a new client for Gatekeeper.Ensure the Gatekeeper client is configured with the proper "audience" token mapper. This is crucial as Gatekeeper expects to be listed in the audience claim of ID tokens brought back by Keycloak.</p>
<ol start="3">
<li>
<p>Gatekeeper Configuration File:</p>
</li>
</ol>
<p>Create a configuration file for Gatekeeper. Here is an example:</p>


```js
discovery-url: https://your-keycloak-instance.com/auth/realms/your-realm/.well-known/openid-configuration
client-id: gatekeeper-client
client-secret: your-client-secret
encryption-key: your-encryption-key
redirect-url: https://your-application-url.com
resources:
  - uri: /protected-path
    methods:
      - GET
      - POST
```
<p>Run Gatekeeper: Start the Gatekeeper service using the configuration file.</p>
```js
  docker run -d --name keycloak-gatekeeper \
  -v /path/to/config.yaml:/config.yaml \
  oneconcern/keycloak-gatekeeper:latest \
  --config /config.yaml
```
<h3>Integrating with Kubernetes</h3>
<p>To integrate Gatekeeper with your Kubernetes deployment, you can use Kubernetes services and ingress resources.</p>
<h4 >Using Ingress Annotations</h4>
<p>You can protect your web applications using ingress annotations. Here&rsquo;s an example of how to configure an Nginx ingress to use OAuth2 Proxy (which can be replaced or complemented with Gatekeeper):</p>
<p>Create an Ingress Resource:</p>
<p>Define an ingress resource with annotations that point to the OAuth2 Proxy or Gatekeeper service.</p>
```js
  apiVersion: networking.k8s.io/v1
  kind: Ingress
  metadata:
    name: protected-ingress
    annotations:
      nginx.ingress.kubernetes.io/auth-type: "oauth2"
      nginx.ingress.kubernetes.io/auth-secret: "oauth2-proxy-client-secret"
      nginx.ingress.kubernetes.io/auth-realm: "Protected Area"
  spec:
    rules:
    - host: your-application-url.com
      http:
        paths:
        - path: /protected-path
          pathType: Prefix
          backend:
            service:
              name: your-service-name
              Port:
  number: 80
 ```
<p>Deploy OAuth2 Proxy or Gatekeeper:</p>
<p>Deploy the OAuth2 Proxy or Gatekeeper service using a Helm chart or a Kubernetes deployment.</p>
```js
helm upgrade --install gatekeeper ./charts/gatekeeper --values gatekeeper/values-gatekeeper.yml
```
<h3>Accessing and Decoding JSON Web Tokens (JWTs)</h3>
<p>Once authenticated, the application can access and decode the Keycloak JSON Web Token (JWT) to implement fine-grained authorization.</p>
<p>Passing the Authorization Header:</p>
<p>Configure Gatekeeper or OAuth2 Proxy to pass the authorization header to the application.</p>
<div align="left">
<table>
<tbody>
<tr>
<td>
```js
pass_authorization_header: true
```
</td>
</tr>
</tbody>
</table>
</div>
<p>Decoding the JWT:</p>
<p>In your application, decode the JWT to extract user information and group memberships.</p>
```js
import jwt

def decode_jwt(token):
    try:
        payload = jwt.decode(token, options={"verify_signature": False})
        return payload
    except jwt.ExpiredSignatureError:
        return "Token has expired"
    except jwt.InvalidTokenError:
        return "Invalid token"

# Example usage
token = request.headers.get('Authorization').split(' ')
user_info = decode_jwt(token)
print(user_info)
```
<h3>Conclusion</h3>
<p>Implementing OAuth2 authorization with Keycloak and Gatekeeper provides a robust and secure authentication mechanism for web applications. Here are some key consequences and considerations:</p>
<p>Gatekeeper improves application security by centralizing authentication and session verification, eliminating the need for authentication logic within the application code and reducing the risk of vulnerabilities. Its scalability is ideal for Kubernetes deployments, and it supports various authentication methods like cookies and bearer tokens. Centralized management of authentication mechanisms simplifies updates and maintenance. Furthermore, using OIDC and OAuth2 with PKCE ensures adherence to security best practices and protects against common threats, making it a robust and compliant solution.</p>
<p>In summary, integrating Keycloak with Gatekeeper provides a comprehensive and secure solution for authentication and authorization, making it an ideal choice for protecting web applications in a Kubernetes environment.</p>
</div>
